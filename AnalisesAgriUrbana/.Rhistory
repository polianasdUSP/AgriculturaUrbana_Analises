ggplot(df_vai, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
ggplot(df_vai, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
save.image("C:/Users/polia/OneDrive/Desktop/EstatisticaR/AgrUrbana/16S_AgriUrbana/AgriculturaUrbana_Analises/Objetos_analises10.RData")
ggplot(df_vai, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
ggplot(df_vai, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
save.image("C:/Users/polia/OneDrive/Desktop/EstatisticaR/AgrUrbana/16S_AgriUrbana/AgriculturaUrbana_Analises/Objetos_analises10.RData")
library(microbiomeMarker)
library(microbiomeMarker)
library(qiime2R)
library(phyloseq)
library(tibble)
library(ggplot2)
library(pheatmap)
library(dplyr)
library(ggplot2)
ggplot(df_vai, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
ggplot(df_vai, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
library(ggplot2)
df_vai$significant <- ifelse(df_vai$FDR < 0.05 & abs(df_vai$log2FC) > 1, "Yes", "No")
ggplot(df_vai, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
df_vai$significant <- ifelse(df_vai$FDR < 0.05 & abs(df_vai$log2FC) > 1, "Yes", "No")
ggplot(df_vai, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
df_vai_filtrado <- df_vai %>%
filter(!is.na(log2FC), !is.na(FDR), is.finite(log2FC), is.finite(FDR))
# Agora, plote o gráfico
ggplot(df_vai_filtrado, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
df_vai_filtrado <- df_vai %>%
filter(!is.na(log2FC), !is.na(FDR), is.finite(log2FC), is.finite(FDR))
library(dplyr)
library(ggplot2)
df_vai_filtrado <- df_vai %>%
filter(!is.na(log2FC), !is.na(FDR), is.finite(log2FC), is.finite(FDR))
# Agora, plote o gráfico
ggplot(df_vai_filtrado, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
# Agora, plote o gráfico
ggplot(df_vai_filtrado, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)", x = "log2 Fold Change", y = "-log10(FDR)") +
theme_minimal()
# Carregar os pacotes necessários
library(ggplot2)
library(dplyr)
# Filtrar os dados para remover NAs e valores infinitos
df_vai_filtrado <- df_vai %>%
filter(!is.na(log2FC), !is.na(FDR), is.finite(log2FC), is.finite(FDR))
# Redefinir variável de significância com base no filtro
df_vai_filtrado <- df_vai_filtrado %>%
mutate(significant = ifelse(FDR < 0.05 & abs(log2FC) > 1, "Yes", "No"))
# Volcano plot
ggplot(df_vai_filtrado, aes(x = log2FC, y = -log10(FDR), color = significant)) +
geom_point(alpha = 0.7) +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs)",
x = "log2 Fold Change",
y = "-log10(FDR)") +
theme_minimal()
df_vai$significant
df_vai
View(df_vai)
SVs_meta
View(SVs_meta)
pvals_vai
View(pares_signif)
pvals_vai
pvals_vai
log2FC_vai
df_vai
View(df_vai)
# Marcar como significativo com base no p-valor cru
df_vai$pval_signif <- ifelse(!is.na(df_vai$pvalue) & df_vai$pvalue < 0.05 & abs(df_vai$log2FC) > 1, "Yes", "No")
library(ggplot2)
ggplot(df_vai, aes(x = log2FC, y = -log10(pvalue), color = pval_signif)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("No" = "gray", "Yes" = "red")) +
labs(
title = "Volcano Plot - VAI (ASVs) usando p-valor",
x = "log2 Fold Change",
y = "-log10(p-value)"
) +
theme_minimal()
ggplot(df_vai, aes(x = log2FC, y = -log10(pvalue), color = pval_signif)) +
geom_point() +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("No" = "gray", "Yes" = "red")) +
labs(
title = "Volcano Plot - VAI (ASVs) usando p-valor",
x = "log2 Fold Change",
y = "-log10(p-value)"
) +
theme_minimal()
asvs_signif_vai <- df_vai %>%
filter(pvalue < 0.05, abs(log2FC) > 1) %>%
arrange(pvalue)
# Visualizar
View(asvs_signif_vai)
# Supondo que o objeto com a taxonomia se chame 'taxonomy'
asvs_signif_vai_tax <- left_join(asvs_signif_vai, taxonomy, by = c("ASV" = "Feature.ID"))
library(ggrepel)
# Filtrar significativas com p < 0.05 e |log2FC| > 1
df_vai_tax <- df_vai %>%
filter(pvalue < 0.05, abs(log2FC) > 1) %>%
left_join(taxonomy, by = c("ASV" = "Feature.ID")) %>%
mutate(label = stringr::str_extract(Taxon, "g__[^;]*"))  # extrai o gênero
# Volcano plot com rótulos
ggplot(df_vai, aes(x = log2FC, y = -log10(pvalue))) +
geom_point(aes(color = pval_signif)) +
geom_text_repel(data = df_vai_tax, aes(label = label), size = 3, max.overlaps = 10) +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs) com taxonomia",
x = "log2 Fold Change", y = "-log10(p-valor)") +
theme_minimal()
ggplot(df_vai, aes(x = log2FC, y = -log10(pvalue))) +
geom_point(aes(color = pval_signif)) +
geom_text_repel(data = df_vai_tax, aes(label = label), size = 3, max.overlaps = 10) +
geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
geom_vline(xintercept = c(-1, 1), linetype = "dashed") +
scale_color_manual(values = c("gray", "red")) +
labs(title = "Volcano Plot - VAI (ASVs) com taxonomia",
x = "log2 Fold Change", y = "-log10(p-valor)") +
theme_minimal()
library(ggplot2)
library(dplyr)
library(ggpubr)
# Calcular abundância relativa por amostra
SVs_rel <- sweep(SVs_filtrado, 2, colSums(SVs_filtrado), FUN = "/")
# Transpor para long format
SVs_long <- as.data.frame(t(SVs_rel))
SVs_long$Sample.id <- rownames(SVs_long)
# Unir com metadados (para ter o grupo VAI)
dados_plot <- SVs_long %>%
left_join(metadados.saude.alpha[, c("Sample.id", "VAI_group")], by = "Sample.id") %>%
filter(!is.na(VAI_group))  # Remover NAs
# Agregar por VAI e Feature
dados_long <- dados_plot %>%
tidyr::pivot_longer(-c(Sample.id, VAI_group), names_to = "ASV", values_to = "Abundancia")
# Juntar com a taxonomia (para obter Genus)
dados_long <- dados_long %>%
left_join(taxonomy[, c("Feature.ID", "Taxon")], by = c("ASV" = "Feature.ID")) %>%
mutate(Genus = stringr::str_extract(Taxon, "g__[^;]+")) %>%
mutate(Genus = gsub("g__", "", Genus),
Genus = ifelse(Genus == "" | is.na(Genus), "Unclassified", Genus))
# Agregar por gênero
dados_genus <- dados_long %>%
group_by(Sample.id, VAI_group, Genus) %>%
summarise(Abundancia = sum(Abundancia), .groups = "drop")
# Selecionar os gêneros mais prevalentes
top_genus <- dados_genus %>%
group_by(Genus) %>%
summarise(mean_abund = mean(Abundancia)) %>%
arrange(desc(mean_abund)) %>%
slice_head(n = 20) %>%
pull(Genus)
# Filtrar para top gêneros
dados_top <- dados_genus %>% filter(Genus %in% top_genus)
# Gráfico com teste de Wilcoxon
ggplot(dados_top, aes(x = VAI_group, y = Abundancia, fill = VAI_group)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(width = 0.2, alpha = 0.4) +
facet_wrap(~ Genus, scales = "free_y") +
stat_compare_means(method = "wilcox.test", label = "p.signif", size = 3) +
labs(title = "Abundância relativa dos principais gêneros por grupo de VAI",
y = "Abundância relativa", x = "Grupo de VAI") +
theme_minimal() +
theme(legend.position = "none")
ggplot(dados_top, aes(x = VAI_group, y = Abundancia, fill = VAI_group)) +
geom_boxplot(outlier.shape = NA) +
geom_jitter(width = 0.2, alpha = 0.4) +
facet_wrap(~ Genus, scales = "free_y") +
stat_compare_means(method = "wilcox.test", label = "p.signif", size = 3) +
labs(title = "Abundância relativa dos principais gêneros por grupo de VAI",
y = "Abundância relativa", x = "Grupo de VAI") +
theme_minimal() +
theme(legend.position = "none")
# Se você ainda não tiver, agrupe os dados por Genus e VAI_group
dados_agrupados <- dados_genus %>%
group_by(Genus, VAI_group) %>%
summarise(Abundancia_media = mean(Abundancia, na.rm = TRUE)) %>%
ungroup()
# Ordena os gêneros por abundância média no grupo Low
generos_ordenados <- dados_agrupados %>%
filter(VAI_group == "Low") %>%
arrange(desc(Abundancia_media)) %>%
pull(Genus)
# Converte Genus em fator com a ordem desejada
dados_agrupados$Genus <- factor(dados_agrupados$Genus, levels = generos_ordenados)
# Gráfico
ggplot(dados_agrupados, aes(x = Genus, y = Abundancia_media, fill = VAI_group)) +
geom_col(position = "dodge") +
labs(title = "Abundância Relativa dos Gêneros por Grupo de VAI",
x = NULL, y = "Abundância Relativa", fill = "Grupo VAI") +
scale_fill_manual(values = c("Low" = "#fdbf11", "High" = "#e66101")) +
theme_minimal(base_size = 14) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Gráfico
ggplot(dados_agrupados, aes(x = Genus, y = Abundancia_media, fill = VAI_group)) +
geom_col(position = "dodge") +
labs(title = "Abundância Relativa dos Gêneros por Grupo de VAI",
x = NULL, y = "Abundância Relativa", fill = "Grupo VAI") +
scale_fill_manual(values = c("Low" = "#fdbf11", "High" = "#e66101")) +
theme_minimal(base_size = 14) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
save.image("C:/Users/polia/OneDrive/Desktop/EstatisticaR/AgrUrbana/16S_AgriUrbana/AgriculturaUrbana_Analises/Objetos_analises10.RData")
# Pacotes necessários
library(dplyr)
library(ggplot2)
library(tidyr)
library(forcats)
# ---- Filtrar apenas os ASVs significativos ----
asvs_significativos <- df_vai %>%
filter(pval_signif == "Yes") %>%
pull(Feature.ID)
pval_signif
library(dplyr)
library(tidyr)
library(ggplot2)
library(forcats)
# 1. Selecionar ASVs significativas pelo p-valor
asvs_significativas <- df_vai %>%
filter(pval_signif == "Yes") %>%
pull(Feature.ID)
# Garante que Feature.ID está como coluna
df_vai <- df_vai %>%
tibble::rownames_to_column("Feature.ID")
# 1. Selecionar ASVs significativas pelo p-valor
asvs_significativas <- df_vai %>%
filter(pval_signif == "Yes") %>%
pull(Feature.ID)
# 2. Filtrar matriz com ASVs significantes
SVs_sig <- SVs_filtrado[asvs_significativas, ]
# 3. Calcular abundância relativa por amostra
SVs_rel <- sweep(SVs_sig, 2, colSums(SVs_sig), FUN = "/") %>% as.data.frame()
# 4. Reorganizar para formato longo
SVs_long <- SVs_rel %>%
tibble::rownames_to_column("Feature.ID") %>%
pivot_longer(-Feature.ID, names_to = "Sample.id", values_to = "Abundancia")
# 5. Adicionar taxonomia e grupo VAI
SVs_long <- SVs_long %>%
left_join(taxonomy, by = "Feature.ID") %>%
left_join(metadados.saude.alpha[, c("Sample.id", "VAI_group")], by = "Sample.id") %>%
mutate(Genus = stringr::str_extract(Taxon, "g__[^;]*")) %>%
mutate(Genus = gsub("g__", "", Genus))
# 6. Calcular média por grupo
abund_por_grupo <- SVs_long %>%
group_by(Genus, VAI_group) %>%
summarise(Abundancia_Relativa = mean(Abundancia, na.rm = TRUE), .groups = "drop") %>%
filter(!is.na(Genus))
# 7. Gráfico
ggplot(abund_por_grupo, aes(x = fct_reorder(Genus, -Abundancia_Relativa),
y = Abundancia_Relativa, fill = VAI_group)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Abundância Relativa dos Gêneros Significativos por Grupo de VAI",
x = "Gênero", y = "Abundância Relativa") +
theme_minimal() +
scale_fill_manual(values = c("#F9A03F", "#D9503F"), name = "Grupo VAI") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(abund_por_grupo, aes(x = fct_reorder(Genus, -Abundancia_Relativa),
y = Abundancia_Relativa, fill = VAI_group)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Abundância Relativa dos Gêneros Significativos por Grupo de VAI",
x = "Gênero", y = "Abundância Relativa") +
theme_minimal() +
scale_fill_manual(values = c("#F9A03F", "#D9503F"), name = "Grupo VAI") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Filtrar apenas as amostras com TyG_group definido
dados_tyg <- metadados.saude.alpha %>%
filter(!is.na(TyG_group))
# Garantir que os IDs estão alinhados
ids_tyg <- dados_tyg$Sample.id
SVs_tyg <- SVs_filtrado[, ids_tyg]
# Verificar intersecção entre os nomes
ids_comuns <- intersect(dados_tyg$Sample.id, colnames(SVs_filtrado))
# Filtrar o metadados e a matriz SVs
dados_tyg <- dados_tyg %>% filter(Sample.id %in% ids_comuns)
SVs_tyg <- SVs_filtrado[, ids_comuns]
save.image("C:/Users/polia/OneDrive/Desktop/EstatisticaR/AgrUrbana/16S_AgriUrbana/AgriculturaUrbana_Analises/Objetos_analises10.RData")
# Carregar pacotes
library(tidyverse)
# Carregar pacotes
library(tidyverse)
library(ggplot2)
library(FSA)
library(dplyr)
# Filtrar apenas os IDs que existem nos dois objetos
ids_comuns <- intersect(dados_tyg$Sample.id, colnames(SVs_filtrado))
# Filtrar metadados e matriz SVs
dados_tyg <- dados_tyg %>% filter(Sample.id %in% ids_comuns)
SVs_tyg <- SVs_filtrado[, ids_comuns]
# Calcular abundância relativa
SVs_tyg_rel <- sweep(SVs_tyg, 2, colSums(SVs_tyg), FUN = "/")
# Adicionar grupo TyG
grupo_tyg <- dados_tyg$TyG_group
names(grupo_tyg) <- dados_tyg$Sample.id
# Calcular médias por grupo
media_por_grupo <- function(mat, grupos) {
grupos_unicos <- unique(grupos)
medias <- sapply(grupos_unicos, function(g) rowMeans(mat[, grupos == g, drop = FALSE]))
return(medias)
}
medias_tyg <- media_por_grupo(SVs_tyg_rel, grupo_tyg)
# Teste de Wilcoxon para cada ASV
pvals <- apply(SVs_tyg_rel, 1, function(x) {
grupo1 <- x[grupo_tyg == "High"]
grupo2 <- x[grupo_tyg == "Low"]
if(length(grupo1) > 0 & length(grupo2) > 0) {
wilcox.test(grupo1, grupo2)$p.value
} else {
NA
}
})
# Calcular log2FC
log2FC <- log2((medias_tyg[, "High"] + 1e-6) / (medias_tyg[, "Low"] + 1e-6))
# Corrigir p-valor com FDR
fdr <- p.adjust(pvals, method = "fdr")
# Montar dataframe
df_tyg <- data.frame(
Feature.ID = rownames(SVs_tyg_rel),
log2FC = log2FC,
pvalue = pvals,
FDR = fdr
)
# Adicionar significância
df_tyg$pval_signif <- ifelse(df_tyg$pvalue <= 0.05 & abs(df_tyg$log2FC) >= 1, "Yes", "No")
# Montar dataframe
df_tyg <- data.frame(
Feature.ID = rownames(SVs_tyg_rel),
log2FC = log2FC,
pvalue = pvals,
FDR = fdr
)
# Calcular médias por grupo
medias_tyg <- media_por_grupo(SVs_tyg_rel, grupo_tyg)
# Calcular médias por grupo
media_por_grupo <- function(mat, grupos) {
grupos_unicos <- unique(grupos)
medias <- sapply(grupos_unicos, function(g) rowMeans(mat[, grupos == g, drop = FALSE]))
return(medias)
}
# Calcular médias por grupo
medias_tyg <- media_por_grupo(SVs_tyg_rel, grupo_tyg)
length(grupo_tyg)
ncol(SVs_tyg_rel)
# Filtrar dados_tyg para manter apenas os IDs presentes em SVs_tyg_rel
dados_tyg_filtrado <- dados_tyg %>%
filter(Sample.id %in% colnames(SVs_tyg_rel)) %>%
arrange(match(Sample.id, colnames(SVs_tyg_rel)))
# Recriar grupo_tyg com os IDs corretos e alinhados
grupo_tyg <- dados_tyg_filtrado$TyG_group
# Calcular médias por grupo
media_por_grupo <- function(mat, grupos) {
grupos_unicos <- unique(grupos)
medias <- sapply(grupos_unicos, function(g) rowMeans(mat[, grupos == g, drop = FALSE]))
return(medias)
}
# Calcular médias por grupo
medias_tyg <- media_por_grupo(SVs_tyg_rel, grupo_tyg)
# Filtrar dados_tyg para manter apenas os IDs presentes em SVs_tyg_rel
dados_tyg_filtrado <- dados_tyg %>%
filter(Sample.id %in% colnames(SVs_tyg_rel)) %>%
arrange(match(Sample.id, colnames(SVs_tyg_rel)))
# Recriar grupo_tyg com os IDs corretos e alinhados
grupo_tyg <- dados_tyg_filtrado$TyG_group
# Calcular médias por grupo
medias_tyg <- media_por_grupo(SVs_tyg_rel, grupo_tyg)
length(grupo_tyg)
ncol(SVs_tyg_rel)
# Filtrar dados_tyg para manter apenas os IDs presentes em SVs_tyg_rel
dados_tyg_filtrado <- dados_tyg %>%
filter(Sample.id %in% colnames(SVs_tyg_rel)) %>%
arrange(match(Sample.id, colnames(SVs_tyg_rel)))
# Recriar grupo_tyg com os IDs corretos e alinhados
grupo_tyg <- dados_tyg_filtrado$TyG_group
# Agora deve funcionar
medias_tyg <- media_por_grupo(SVs_tyg_rel, grupo_tyg)
# 1. Obter os IDs presentes nas colunas da matriz
ids_comuns <- intersect(colnames(SVs_tyg_rel), dados_tyg$Sample.id)
# 2. Reordenar a matriz e os grupos com base nesses IDs
SVs_tyg_rel_filtrado <- SVs_tyg_rel[, ids_comuns]
# 3. Garantir que os grupos estão na mesma ordem dos IDs na matriz
grupo_tyg <- dados_tyg %>%
filter(Sample.id %in% ids_comuns) %>%
arrange(match(Sample.id, ids_comuns)) %>%
pull(TyG_group)
# 4. Verificar se agora bate:
print(length(grupo_tyg))            # Deve ser igual a ncol(SVs_tyg_rel_filtrado)
print(ncol(SVs_tyg_rel_filtrado))  # Deve ser igual ao anterior
# 1. Obter os IDs presentes nas colunas da matriz
ids_comuns <- intersect(colnames(SVs_tyg_rel), dados_tyg$Sample.id)
# 2. Reordenar a matriz e os grupos com base nesses IDs
SVs_tyg_rel_filtrado <- SVs_tyg_rel[, ids_comuns]
# 3. Garantir que os grupos estão na mesma ordem dos IDs na matriz
grupo_tyg <- dados_tyg %>%
filter(Sample.id %in% ids_comuns) %>%
arrange(match(Sample.id, ids_comuns)) %>%
pull(TyG_group)
# 4. Verificar se agora bate:
print(length(grupo_tyg))            # Deve ser igual a ncol(SVs_tyg_rel_filtrado)
print(ncol(SVs_tyg_rel_filtrado))  # Deve ser igual ao anterior
# Refazer ids_comuns com base apenas nos que estão em ambas as fontes
ids_comuns <- intersect(dados_tyg$Sample.id, colnames(SVs_tyg_rel))
# Filtrar e ordenar matriz
SVs_tyg_rel_filtrado <- SVs_tyg_rel[, ids_comuns]
# Filtrar e ordenar os grupos exatamente com os mesmos IDs
grupo_tyg <- dados_tyg %>%
filter(Sample.id %in% ids_comuns) %>%
arrange(match(Sample.id, ids_comuns)) %>%
pull(TyG_group)
# Verificar novamente
print(length(grupo_tyg))
print(ncol(SVs_tyg_rel_filtrado))
grupo_tyg
SVs_tyg_rel_filtrado
# Verificar novamente
print(length(grupo_tyg))
print(ncol(SVs_tyg_rel_filtrado))
View(SVs_tyg_rel_filtrado)
# Ver quais IDs estão em dados_tyg mas não em SVs_tyg_rel_filtrado
setdiff(dados_tyg$Sample.id, colnames(SVs_tyg_rel_filtrado))
colnames(SVs_tyg_rel_filtrado)
colnames(grupo_tyg)
# Ordena os dados de acordo com a ordem dos IDs da matriz
ids_tyg <- colnames(SVs_tyg_rel_filtrado)
dados_tyg_ordenado <- dados_tyg %>%
filter(Sample.id %in% ids_tyg) %>%
arrange(match(Sample.id, ids_tyg))
# Cria o vetor do grupo TyG
grupo_tyg <- dados_tyg_ordenado$TyG_group
# Checagens finais
length(grupo_tyg) == ncol(SVs_tyg_rel_filtrado)  # Deve dar TRUE
all(dados_tyg_ordenado$Sample.id == colnames(SVs_tyg_rel_filtrado))  # Também TRUE
class(grupo_tyg)
str(grupo_tyg)
# Verifica se há amostras duplicadas
duplicated_ids <- dados_tyg$Sample.id[duplicated(dados_tyg$Sample.id)]
duplicated_ids
# Remove duplicatas mantendo apenas a primeira ocorrência
dados_tyg_ordenado <- dados_tyg[!duplicated(dados_tyg$Sample.id), ]
# Verifica se agora está alinhado
all(dados_tyg_ordenado$Sample.id == colnames(SVs_tyg_rel_filtrado))  # Deve dar TRUE
grupo_tyg <- dados_tyg_ordenado$TyG_grupo
# Verifica os grupos disponíveis
table(grupo_tyg)
grupo_tyg
